---
title: "操作系统系列之——程序与进程"
date: 2020-12-22T21:24:06+08:00
tags: ["os", "procedure", "process", "unix-like", "c"]
categories: ["code", "os"]
draft: false
---


> 以下命令在类Unix（Linux、macOS）命令行中运行。

## 1. 什么是程序

> 计算机程序是**一组**指示电子计算机或其他具有消息处理能力设备每一步动作的**指令**。————《[维基百科：计算机程序](https://zh.wikipedia.org/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A8%8B%E5%BA%8F)》

举个例子，当你写了一段`C语言`的**经典HelloWorld**：

```c
#include <stdio.h>
int main(){
    printf("HelloWorld!");
    return 0;
}
```

将上面这段经典保存为`main.c`，然后利用`gcc`编译工具去编译源代码：

```bash
gcc main.c
```

现在main.c所在文件夹包含内容如下：

- main.c
- a.out

通过gcc编译后得到了一个二进制可执行文件`a.out`。此时它被保存在硬盘的中，只要你愿意随时都可以执行这个文件，**这个`a.out`就是一个程序**。

## 2. 什么是进程

> 进程本质上是正在执行的一个程序，是对正在运行程序的一个抽象。——《现代操作系统》

继续`1`中的例子，`a.out`是存放在硬盘中的**程序**，当它被计算机执行时，就会产生一个进程。

直接在`a.out`所在目录通过相对路径执行这个程序，可以看到程序运行并将字符输出到了控制台中：

> 其中`➜  c`是命令提示符，请忽略该部分，关注后面的内容。

```bash
➜  c ./a.out 
HelloWorld!                                                                                                     
➜  c 
```

由于我们的程序非常简单，在非常短的时间内这个程序被执行时产生的**进程**就运行完毕了，**命令提示符**因此也再次出现，提醒我们可以进行新的操作。

如果你还是懵懵懂懂，感觉程序和进程没有区别，让我们继续做一个实验：

### 2.1. 进程的小实验

> 再次强调，以下代码适用于类Unix系统，不同操作系统之间需要使用的库和编译工具会有所不同。

首先改造一下我们的经典，引入了`unistd`来实现睡眠功能，我们的程序现在会每隔`4s`输出一条**带有编号的HelloWorld**，一共输出三条。

```c
#include <stdio.h>
#include <unistd.h>
#define SLEEP_SECONDS 4
int main(){
    for(int i=0; i < 3; i++){
        sleep(SLEEP_SECONDS);
        printf("No.%d: HelloWorld!\n",i);
    }
    return 0;
}
```

编译并运行一次查看效果，是符合我们编写代码的预期的：

```bash
➜  c ./a.out
No.0: HelloWorld!
No.1: HelloWorld!
No.2: HelloWorld!
➜  c 
```

接下来就要进入重点了，我们需要用到`&`这个符号，这在命令行中意味着后台运行，当没有&时我们需要等待a.out运行完毕才可以继续下一个命令操作，有了&系统就会把我们要运行的程序挂到后台运行，不影响我们的下一步操作。

尝试一下加上`&`会有什么变化：

```bash
➜  c ./a.out &
[1] 63965
➜  c No.0: HelloWorld!
No.1: HelloWorld!
No.2: HelloWorld!

[1]  + 63965 done       ./a.out
➜  c 
```

可以看到加上&后输出了`[1] 63965`，暂时不用理会这个信息，我们可以注意到命令提示符马上就再次出现了，这意味着我们可以进行下一步的操作而不用等待a.out的运行，并且我们可以看到a.out的运行结果同样是输出到了当前的控制台上。

现在我们可以知道&的作用：

- 让程序在后台运行
- 程序的输出依然不受影响

我们做最后一个实验，在执行完第一次的`./a.out &`后，马上通过键盘的方向上键`↑`呼出`./a.out &`再次执行一遍，也就是一共执行了两遍。

```bash
➜  c ./a.out &
[1] 63691
➜  c ./a.out &
[2] 63694
➜  c No.0: HelloWorld!
No.0: HelloWorld!
No.1: HelloWorld!
No.1: HelloWorld!
No.2: HelloWorld!

[1]  - 63691 done       ./a.out
➜  c No.2: HelloWorld!

[2]  + 63694 done       ./a.out
➜  c 
```

输出的结果并不是`0-1-2-0-1-2`，而是`0-0-1-1-2-2`，这说明有两个a.out程序在同时运行且输出结果，先启动的先输出，后启动的则晚一点点输出，但是晚的时间间隔还不足我们设置的睡眠时间4秒，因此出现了两个一样的结果并排的现象。如果你更改两次`./a.out &`的执行时间间隔，会得到更加混乱的结果。

`a.out`是我们的程序，但它仅仅存放在硬盘上时它是**死的**，只有执行起来时才会产生**活的进程**。显然上面的结果是因为**两次**运行产生了**两个**进程，并且两个进程是同时运行（或者说是**并发的**）导致的。也就是说我们的一个程序事实上可以对应无数个进程，*进程仅仅是正在执行的一个程序的抽象*。

> 以书中一个很棒的例子作为结束：进程和程序间的区别是很微妙的，但非常重要。用一个比喻可以更容易理解这一点。想象一位有一手好厨艺的计算机科学家正在为她的女儿烘制生日蛋糕。他有做生日蛋糕的食谱，厨房里有所需的原料：面粉、鸡蛋、糖、香草汁等。在这个比喻中。做蛋糕的食谱就是程序，计算机科学家就是处理器（CPU）。而做蛋糕的各种原料就是输入数据。进程就是厨师阅读食谱、取来各种原料以及烘制蛋糕等一系列动作的总和。
